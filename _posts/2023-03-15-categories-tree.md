---
title: "[자료구조] Tree 트리"
excerpt: "비선형 자료구조 중 하나인 Tree에 대해 알아보자"

categories:
  - Data Structure
tags:
  - [Tree, 자료구조]

permalink: /Data Structure/Tree

toc: true
toc_sticky: true

date: 2023-03-15
last_modified_at: 2023-03-15
---
<hr>

## 🌲 Tree
- 그래프의 여러 구조 중 단방향 그래프의 한 구조로, 하나의 뿌리로부터 가지가 사방으로 뻗은 형태가 나무와 닮아다고 해서 트리 구조라고 부른다.
- 데이터가 바로 아래에 있는 하나 이상의 데이터에 한 개의 경로와 하나의 방향으로만 연결된 **계층적 자료구조**이다.
- 데이터를 순차적으로 나열시킨 선형 구조가 아니라, 하나의 데이터 아래에 여러 개의 데이터가 존재할 수 있는 **비선형 구조**이다.
- 트리 구조는 계층적으로 표현이 되고, 아래로만 뻗어나가기 때문에 사이클(cycle)이 없다. 
<blockquote class="ex">
시작 노드에서 출발해 다른 노드를 거쳐 시작 노드로 돌아올 수 있다면 사이클이 존재한다고 표현한다. <br>
따라서 트리는 사이클(cycle)이 없는 하나의 연결 그래프 (Connected Graph)라고 할 수 있다.
</blockquote>

<hr class="sub">

### 🍃 Tree 구조, 특징

<figure>
  <img src="/assets/images/posts_img/tree/tree1.png">
  <figcaption>출처: 코드스테이츠</figcaption>
</figure>
- 트리 구조는 루트(Root) 라는 하나의 꼭짓점 데이터를 시작으로 여러 개의 데이터를 간선(edge)으로 연결합니다.
- 각 데이터를 노드(Node)라고 하며, 두 개의 노드가 상하 계층으로 연결되면 부모/자식 관계를 가진다.
<blockquote class="ex">
위 그림에서<br>
<strong>부모 노드(Parent Node)</strong> : <strong>A</strong>는 ,B와 C의 부모노드 <br>
<strong>자식 노드(Child Node)</strong> : <strong>B와 C</strong>는 A의 자식 노드 <br>
<strong>리프 노드(Leaf Node)</strong> : 자식이 없는 노드는 나무의 잎과 같다고 하여 리프 노드라고 부른다.
</blockquote>


- 자료구조 Tree는 깊이와 높이, 레벨 등을 측정할 수 있다.

<figure>
  <img src="/assets/images/posts_img/tree/tree2.png">
  <figcaption>출처: 코드스테이츠</figcaption>
</figure>

<h3 class="sub-title">✅ 깊이 (depth)</h3>
- 트리 구조에서는 **루트로부터 하위 계층의 특정 노드까지의 깊이(depth)**를 표현할 수 있다.
- 루트 노드는 지면에 있는 것처럼 깊이가 0이다.
<blockquote class="ex">
위 그림에서<br>
- 루트 A의 깊이는 0 <br>
- B와 C의 깊이는 1 <br>
- D, E, F, G의 깊이는 2
</blockquote>

<h3 class="sub-title">✅ 레벨(Level)</h3>
- 트리 구조에서 **같은 깊이**를 가지고 있는 노드를 묶어서 레벨(level)로 표현할 수 있다.
<blockquote class="ex">
- 깊이가 0인 루트 A의 level은 1<br>
- 깊이가 1인 B와 C의 level은 2<br>
- D, E, F, G의 레벨은 3
</blockquote>
- 같은 레벨에 나란히 있는 노드를 **형제 노드(Sibling Node)** 라고 한다.

<h3 class="sub-title">✅ 높이(Height)</h3>
- 트리 구조에서 **리프 노드를 기준으로 루트까지의 높이(height)**를 표현할 수 있다.
- 리프 노드와 직간접적으로 연결된 노드의 높이를 표현한다.
- 부모 노드는 자식 노드의 가장 높은 높이 값에 +1한 값을 높이로 가진다.
- 트리 구조의 높이를 표현할 때는 각 리프 노드의 높이를 0으로 놓는다.
<blockquote class="ex">
위 그림에서<br>
- H, I, E, F, J의 높이는 0 <br>
- D와 G의 높이는 1 <br>
- B와 C의 높이는 2 <br>
- 이때 B는 D의 height + 1을, C는 G의 height + 1을 높이로 가진다. <br>
- 따라서, 루트 A의 높이는 3이다.
</blockquote>

<h3 class="sub-title">✅ 서브 트리(Sub tree)</h3>
- 트리 구조의 루트에서 뻗어 나오는 큰 트리의 내부에, 트리 구조를 갖춘 작은 트리를 서브 트리 라고 부른다.
- (D, H, I)로 이루어진 작은 트리도 서브 트리이고, (B, D, E)나 (C, F, G, J)도 서브 트리이다.

<br>

>자료구조는 자료의 집합을 구조화하고, 이를 표현하는 데에 초점이 맞춰져 있다. <br>
자료구조는 사람이 사용하기에 편리하려고, 사용하기 좋으려고 만들어진 것이다.

<hr class="sub">

### 🍃 Tree의 실사용 예제
가장 대표적인 예제는 컴퓨터의 디렉토리 구조이다.
- 어떤 프로그램이나 파일을 찾을 때, 바탕화면 폴더나 다운로드 폴더 등에서 다른 폴더에 진입하고,
- 또 그 안에서 다른 폴더에 진입하면서 원하는 프로그램이나 파일을 찾는다.
- 모든 폴더는 하나의 폴더(루트 폴더, /)에서 시작되어, 가지를 뻗어나가는 모양새를 띈다.
<img src="/assets/images/posts_img/tree/tree3.png">

- 하나의 폴더 안에 여러 개의 폴더가 있고, 또 그 여러 개의 폴더 안에 또 다른 폴더나 파일이 있다.
- 제일 첫 번째 폴더에서 출발하여 도착하려는 폴더로 가는 경로는 유일하다.
- 사용자들이 사용하기 편하게 사용하기 위한 파일 시스템 등에서는 트리 구조를 이용해 만들어져 있다.

그 외에 월드컵 토너먼트 대진표, 가계도(족보), 조직도 등도 트리구조이다.

<br>

>트리 구조는 편리한 구조를 전시하는 것 외에 효율적인 탐색을 위해 사용하기도 한다. <br>
트리 구조는 가지고 있는 특징에 따라 여러 가지 이름으로 불린다.<br>
많은 트리의 모습 중, 가장 간단하고 많이 사용하는 **이진 트리(binary tree)**와 **이진 탐색 트리(binary search tree)**에 대해 알아보자.
<hr>

## 🌲 Binary tree
- 이진 트리(Binary tree)는 자식 노드가 최대 두 개인 노드로 구성된 트리이다.
- 이 두 개의 자식 노드는 왼쪽 자식 노드와 오른쪽 자식 노드로 나눌 수 있다.
- 이진 트리는 **자료의 삽입, 삭제 방법**에 따라 아래와 같이 나뉜다.
<img src="/assets/images/posts_img/tree/tree4.png">

1. `정 이진 트리(Full binary tree):` 각 노드가 0개 혹은 2개의 자식 노드를 갖는다.
2. `포화 이진 트리(Perfect binary tree):` 정 이진 트리이면서 완전 이진 트리인 경우이다. 모든 리프 노드의 레벨이 동일하고, 모든 레벨이 가득 채워져 있는 트리입니다.
3. `완전 이진 트리(Complete binary tree):` 마지막 레벨을 제외한 모든 노드가 가득 차 있어야 하고, 마지막 레벨의 노드는 전부 차 있지 않아도 되지만 왼쪽이 채워져야 한다.

이러한 이진 트리는 이진 탐색 트리와 이진 힙 구현에 사용되며, 효율적인 검색과 정렬을 위해 사용된다.

<hr>

## 🌲 Binary Search Tree
이진 탐색 트리란 <em>*이진 탐색</em>의 속성이 이진 트리에 적용된 특별한 형태의 이진 트리이다.

<blockquote class="ex">
*이진 탐색이란? <br>

이진 탐색 알고리즘이란 정렬된 데이터 중에서 특정한 값을 찾기 위한 탐색 알고리즘 중 하나이다.  <br>
이진 탐색 알고리즘은 오름차순으로 정렬된 정수의 배열을 같은 크기의 두 부분 배열로 나눈 후,  <br>
두 부분 중 탐색이 필요한 부분에서만 탐색하도록 탐색 범위를 제한하여 원하는 값을 찾는 알고리즘이다.
<ol>
<li>배열의 중간에 내가 찾고자 하는 값이 있는지 확인한다. </li>
<li>중간값이 내가 찾고자 하는 값이 아닐 경우, 오름차순으로 정렬된 배열에서 중간값보다 큰 값인지 작은 값인지 판단한다. </li>
<li>찾고자 하는 값이 중간값보다 작은 값일 경우, 배열의 맨 앞부터 중간값 전까지의 범위를 탐색 범위로 잡고 탐색을 반복 수행한다. </li>
<li>찾고자 하는 값이 중간값보다 큰 값일 경우, 배열의 중간값의 다음 값부터 맨 마지막까지를 탐색 범위로 잡고 탐색을 반복 수행한다.</li>
</ol>
</blockquote>


- 각 노드에 중복되지 않는 키(Key)가 있다.
- 루트노드의 왼쪽 서브 트리는 해당 노드의 키보다 작은 키를 갖는 노드들로 이루어져 있다.
- 루트노드의 오른쪽 서브 트리는 해당 노드의 키보다 큰 키를 갖는 노드들로 이루어져 있다.
- 좌우 서브 트리도 모두 이진 탐색 트리여야 한다.

> 즉 이진 탐색 트리(Binary Search Tree)는 **모든 왼쪽 자식의 값이 루트나 부모보다 작고, 모든 오른쪽 자식의 값이 루트나 부모보다 큰 값을 가지는 특징**이 있다.<br>
예를 들어서 다음과 같은 트리가 이진 탐색 트리이다.

<img src="/assets/images/posts_img/tree/tree5.png">

이진 탐색 트리는 균형 잡힌 트리가 아닐 때, 입력되는 값의 순서에 따라 한쪽으로 노드들이 몰리게 될 수 있다.
균형이 잡히지 않은 트리는 탐색하는 데 시간이 더 걸리는 경우도 있기 때문에 해결해야할 문제이다.
균형이 잡히지 않은 트리 탐색 문제를 해결하기 위해 삽입과 삭제 마다 ‘트리의 구조를 재조정’하는 과정을 거치는 알고리즘을 추가할 수 있다.

<hr class="sub">

### 🍃 이진 탐색 트리 특징
- 이진 탐색 트리는 기존 이진 트리보다 탐색이 빠르다.
- 이진 탐색 트리의 연산은 트리의 높이가 h(height)라면 o(h)의 복잡도를 가지게 된다.
- 이와 같은 효율적인 연산이 가능한 이유는 탐색 과정에 있다.
<blockquote class="ex">
이진 탐색 트리의 탐색 과정
<br>
<ol>
<li>루트 노드의 키와 찾고자 하는 값을 비교합니다. 만약 찾고자 하는 값이라면 탐색을 종료합니다.</li>
<li>찾고자 하는 값이 루트 노드의 키보다 작다면 왼쪽 서브 트리로 탐색을 진행합니다.</li>
<li>찾고자 하는 값이 루트 노드의 키보다 크다면 오른쪽 서브 트리로 탐색을 진행합니다.</li>
</ol>
<br>
이 과정을 찾고자 하는 값을 찾을 때까지 반복해 진행합니다. 만약 값을 찾지 못한다면 그대로 연산을 종료하게 됩니다. 이러한 탐색 과정을 거치면 최대 트리의 높이(h)만큼 탐색을 진행합니다.
</blockquote>

<hr>

## 🌲 Tree Traversal
이진트리와 이진탐색트리는 다른 개념이다. 
이진트리는 정렬이 되어 있지 않고, 이진탐색트리는 정렬이 되어 있어서 중간값이 루트에 위치해 있다.
정렬이 되어있어 탐색이 빠른 이진탐색에 비해 이진트리는 특정 값을 찾을 때 노드를 한번씩 방문해야한다. 이것을 트리 순회라고 한다.

>
- 특정 목적을 위해 트리의 모든 노드를 한 번씩 방문하는 것을 트리 순회라고 한다.
- 트리 구조는 계층적 구조라는 특별한 특징을 가지기 때문에, 모든 노드를 순회하는 방법엔 크게 세 가지가 있다.
- 트리를 순회할 수 있는 세 가지 방법은 전위 순회, 중위 순회, 후위 순회이다
- 이 순회 방식들은 모두 노드를 순회할 때 **왼쪽부터 오른쪽으로 조회**한다는 공통점이 있다.
- 순회하다가 `null`을 만나면 불러낸 node로 돌아가서 다시 순회함. (재귀)

<hr class="sub"> 

### 🍃 전위순회 (preorder traverse)
<img src="/assets/images/posts_img/tree/traverse1.gif">
- 루트 ➡️ 왼쪽 ➡️ 오른쪽
- 전위 순회에서 가장 먼저 방문하는 노드는 루트
- 루트에서 시작해 왼쪽의 노드들을 순차적으로 둘러본 뒤, 왼쪽의 노드 탐색이 끝나면 오른쪽 노드를 탐색한다.
- 즉 부모 노드가 제일 먼저 방문 되는 순회 방식이다.
- 전위 순회는 주로 트리를 복사할 때 사용한다.

<hr class="sub"> 

### 🍃 중위 순회 (inorder traverse)
<img src="/assets/images/posts_img/tree/traverse2.gif">
- 왼쪽 ➡️ 루트 ➡️ 오른쪽
- 중위 순회는 루트를 가운데에 두고 순회
- 제일 왼쪽 끝에 있는 노드부터 순회하기 시작해, 루트를 기준으로 왼쪽에 있는 노드의 순회가 끝나면 루트를 거쳐 오른쪽에 있는 노드로 이동하여 마저 탐색한다.
- 부모 노드가 서브 트리의 방문 중간에 방문되는 순회 방식이다.
- 중위 순회는 이진 탐색 트리의 오름차순으로 값을 가져올 때 쓰인다.

<hr class="sub">

### 🍃 후위 순회 (postorder traverse)
<img src="/assets/images/posts_img/tree/traverse3.gif">
- 왼쪽 ➡️ 오른쪽 ➡️ 루트
- 후위 순회는 루트를 가장 마지막에 순회
- 제일 왼쪽 끝에 있는 노드부터 순회하기 시작해, 루트를 거치지 않고 오른쪽으로 이동해 순회한 뒤, 제일 마지막에 루트를 방문한다.
- 후위 순회는 트리를 삭제할 때 사용한다. (자식 노드가 먼저 삭제되어야 상위 노드를 삭제할 수 있기 때문)

<hr class="sub">

### 🍃 레벨 순회 (levelorder traverse)
<img src="/assets/images/posts_img/tree/traverse4.gif">
- 레벨 순회는 루트를 방문하는 기준으로 순회를 하는 것이 아닌 트리의 레벨 기준으로 노드들을 방문하는 순회 방법이다.
- 루트 노드를 시작으로 아래로 뻗어나가며 노드들을 방문한다.
- 루트 노드의 레벨이 1레벨이라고 했을 때 아래로 내려갈수록 레벨은 증가하는 특징을 보인다.
- 동일한 레벨에 여러 노드가 존재할 경우 왼쪽에서 오른쪽 순서로 노드를 방문한다.

<hr class="sub">

### 👀 순회 방식을 나누는 이유
- 앞서 배운 이진 트리 탐색의 경우는 간단한 편이지만 순회 방법은 조금 복잡한 편이다.
- 일정 조건에 의해 설계된 트리 구조는 자식 노드에 대한 조건이 명확하다면 원하는 값을 쉽게 찾아낼 수 있게 되지만, 트리 구조 전체를 탐색할 때는 이야기가 조금 달라지기 때문이다.
- 모든 노드를 방문하기 위해서는 일정한 조건이 필요하고, 트리 구조를 유지보수하거나 특정 목적을 위해서도 순회 방법에 대한 정의는 필수적으로 필요하다.